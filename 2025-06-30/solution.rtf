{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fswiss\fcharset0 ArialMT;
\f3\fmodern\fcharset0 Courier;\f4\fnil\fcharset0 .SFNSMono-Light_YAXS14FD5C2_wght2BC0000;\f5\fnil\fcharset0 Menlo-Regular;
\f6\fnil\fcharset0 Menlo-Italic;\f7\froman\fcharset0 Times-Bold;\f8\fnil\fcharset0 HelveticaNeue;
\f9\froman\fcharset0 Times-Roman;\f10\froman\fcharset0 Times-Italic;\f11\fnil\fcharset0 .SFNS-Regular_wdth_opsz110000_GRAD_wght2580000;
\f12\fnil\fcharset0 HelveticaNeue-Bold;}
{\colortbl;\red255\green255\blue255;\red25\green61\blue255;\red40\green41\blue48;\red255\green255\blue255;
\red15\green16\blue19;\red0\green0\blue255;\red255\green255\blue254;\red0\green0\blue0;\red22\green107\blue41;
\red144\green1\blue18;\red240\green240\blue240;\red6\green6\blue6;\red221\green221\blue225;\red184\green93\blue213;
\red30\green33\blue39;\red155\green162\blue177;\red197\green136\blue83;\red81\green157\blue235;\red74\green80\blue93;
\red136\green185\blue102;\red249\green249\blue249;\red15\green15\blue15;\red212\green212\blue212;\red19\green19\blue19;
}
{\*\expandedcolortbl;;\cssrgb\c13005\c35866\c100000;\cssrgb\c20784\c21176\c24706;\cssrgb\c100000\c100000\c100000;
\cssrgb\c7059\c7843\c9412;\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;\cssrgb\c7451\c48627\c21176;
\cssrgb\c63922\c8235\c8235;\cssrgb\c95294\c95294\c95294\c91765;\cssrgb\c1961\c1961\c1961;\cssrgb\c89412\c89412\c90588;\cssrgb\c77647\c47059\c86667;
\cssrgb\c15686\c17255\c20392;\cssrgb\c67059\c69804\c74902;\cssrgb\c81961\c60392\c40000;\cssrgb\c38039\c68627\c93725;\cssrgb\c36078\c38824\c43922;
\cssrgb\c59608\c76471\c47451;\cssrgb\c98039\c98039\c98039;\cssrgb\c7059\c7059\c7059;\cssrgb\c86275\c86275\c86275;\cssrgb\c9804\c9804\c9804;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww14380\viewh7260\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\qc\partightenfactor0

\f0\b\fs28 \cf2 \ul \ulc2 Daily Questions Coding Questions\cf0 \ulc0  
\f1\b0\fs24 \ulnone \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0
\cf0 Question 1.\
\
\pard\pardeftab720\partightenfactor0

\f2\fs28 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 An\'a0
\f1 \AppleTypeServices\AppleTypeServicesF65539 array
\f2 \AppleTypeServices\AppleTypeServicesF65539 \'a0is a data structure that stores elements of the same type in a contiguous block of memory. In an array,\'a0, of size\'a0, each memory location has some unique index,\'a0\'a0(where\'a0), that can be referenced as\'a0\'a0or\'a0.\cb1 \
\cb4 Your task is to reverse an array of integers.\cb1 \
\pard\pardeftab720\partightenfactor0

\f0\b \AppleTypeServices\AppleTypeServicesF65539 \cf5 \cb4 \strokec5 Note:
\f2\b0 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \strokec3 \'a0If you've already solved our C++ domain's\'a0
\f1 \AppleTypeServices\AppleTypeServicesF65539 Arrays Introduction
\f2 \AppleTypeServices\AppleTypeServicesF65539 \'a0challenge, you may want to skip this.\cb1 \

\f0\b \AppleTypeServices\AppleTypeServicesF65539 \cf5 \cb4 \strokec5 Example\
A[1,2,3]
\f2\b0 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb1 \strokec3 \
\pard\pardeftab720\partightenfactor0
\cf3 \cb4 Return [3,2,1]\'a0.\cb1 \
\pard\pardeftab720\partightenfactor0

\f0\b \AppleTypeServices\AppleTypeServicesF65539 \cf5 \cb4 \strokec5 Function Description
\f2\b0 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb1 \strokec3 \
\pard\pardeftab720\partightenfactor0
\cf3 \cb4 Complete the function\'a0\'a0with the following parameter(s):\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f1 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}int A[n]\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 : the array to reverse\cb1 \
\pard\pardeftab720\partightenfactor0

\f0\b \AppleTypeServices\AppleTypeServicesF65539 \cf5 \cb4 \strokec5 Returns
\f2\b0 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb1 \strokec3 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0
\f1 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}int [n]\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec3 : the reversed array\cb1 \
\pard\pardeftab720\partightenfactor0

\f0\b \AppleTypeServices\AppleTypeServicesF65539 \cf5 \cb4 \strokec5 Input Format
\f2\b0 \AppleTypeServices\AppleTypeServicesF65539 \cf3 \cb1 \strokec3 \
\pard\pardeftab720\partightenfactor0
\cf3 \cb4 The first line contains an integer,\'a0, the number of integers in A\'a0.
\f1 \AppleTypeServices\AppleTypeServicesF65539 \cb1 \uc0\u8232 
\f2 \AppleTypeServices\AppleTypeServicesF65539 \cb4 The second line contains\'a0\'a0space-separated integers that make up\'a0A.\cb1 \
\
My approach to reverse an array - \
class Main \{\
    public static void main(String[] args) \{\
        System.out.println("Try programiz.pro");\
        \
        int[] arr = \{5, 2, 3, 4, 6, 7, 1\};\
        int left = 0;\
        int right = arr.length -1;\
        while(left<right) \{\
            int temp = arr[left];\
            arr[left] = arr[right];\
            arr[right] = temp;\
            left++;\
            right--;\
        \}\
        \
        for(int i =0;i<arr.length;i++) \{\
            System.out.println(arr[i]);\
        \}\
    \}\
\}\
\
HackerRank Approach - \
\pard\pardeftab720\partightenfactor0

\f3\fs30 \AppleTypeServices \cf6 \cb7 \strokec6 class\cf0 \strokec8  Result \{\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf9 \strokec9 /*\cf0 \cb1 \strokec8 \
\pard\pardeftab720\partightenfactor0
\cf9 \cb7 \strokec9      * Complete the 'reverseArray' function below.\cf0 \cb1 \strokec8 \
\cf9 \cb7 \strokec9      *\cf0 \cb1 \strokec8 \
\cf9 \cb7 \strokec9      * The function is expected to return an INTEGER_ARRAY.\cf0 \cb1 \strokec8 \
\cf9 \cb7 \strokec9      * The function accepts INTEGER_ARRAY a as parameter.\cf0 \cb1 \strokec8 \
\cf9 \cb7 \strokec9      */\cf0 \cb1 \strokec8 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf6 \strokec6 public\cf0 \strokec8  \cf6 \strokec6 static\cf0 \strokec8  List<Integer> reverseArray(List<Integer> a) \{\cb1 \
\cb7     \cf9 \strokec9 // Write your code here\cf0 \cb1 \strokec8 \
\cb7         \cf6 \strokec6 int\cf0 \strokec8  left = \cf9 \strokec9 0\cf0 \strokec8 ;\cb1 \
\cb7         \cf6 \strokec6 int\cf0 \strokec8  right = a.size() - \cf9 \strokec9 1\cf0 \strokec8 ;\cb1 \
\cb7     \cb1 \
\cb7         \cf6 \strokec6 while\cf0 \strokec8  (left < right) \{\cb1 \
\cb7             \cf9 \strokec9 // Swap elements at left and right\cf0 \cb1 \strokec8 \
\cb7             \cf6 \strokec6 int\cf0 \strokec8  temp = a.get(left);\cb1 \
\cb7             a.set(left, a.get(right));\cb1 \
\cb7             a.set(right, temp);\cb1 \
\cb7             \cb1 \
\cb7             left++;\cb1 \
\cb7             right--;\cb1 \
\cb7         \}\cb1 \
\cb7     \cb1 \
\cb7         \cf6 \strokec6 return\cf0 \strokec8  a;\cb1 \
\cb7     \cb1 \
\cb7     \}\cb1 \
\
\cb7 \}\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb7 \strokec6 public\cf0 \strokec8  \cf6 \strokec6 class\cf0 \strokec8  Solution \{\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb7     \cf6 \strokec6 public\cf0 \strokec8  \cf6 \strokec6 static\cf0 \strokec8  \cf6 \strokec6 void\cf0 \strokec8  main(String[] args) \cf6 \strokec6 throws\cf0 \strokec8  IOException \{\cb1 \
\cb7         BufferedReader bufferedReader = \cf6 \strokec6 new\cf0 \strokec8  BufferedReader(\cf6 \strokec6 new\cf0 \strokec8  InputStreamReader(System.in));\cb1 \
\cb7         BufferedWriter bufferedWriter = \cf6 \strokec6 new\cf0 \strokec8  BufferedWriter(\cf6 \strokec6 new\cf0 \strokec8  FileWriter(System.getenv(\cf10 \strokec10 "OUTPUT_PATH"\cf0 \strokec8 )));\cb1 \
\
\cb7         \cf6 \strokec6 int\cf0 \strokec8  arrCount = Integer.parseInt(bufferedReader.readLine().trim());\cb1 \
\
\cb7         List<Integer> arr = Stream.of(bufferedReader.readLine().replaceAll(\cf10 \strokec10 "\\\\s+$"\cf0 \strokec8 , \cf10 \strokec10 ""\cf0 \strokec8 ).split(\cf10 \strokec10 " "\cf0 \strokec8 ))\cb1 \
\cb7             .map(Integer::parseInt)\cb1 \
\cb7             .collect(toList());\cb1 \
\
\cb7         List<Integer> res = Result.reverseArray(arr);\cb1 \
\
\cb7         bufferedWriter.write(\cb1 \
\cb7             res.stream()\cb1 \
\cb7                 .map(Object::toString)\cb1 \
\cb7                 .collect(joining(\cf10 \strokec10 " "\cf0 \strokec8 ))\cb1 \
\cb7             + \cf10 \strokec10 "\\n"\cf0 \cb1 \strokec8 \
\cb7         );\cb1 \
\
\cb7         bufferedReader.close();\cb1 \
\cb7         bufferedWriter.close();\cb1 \
\cb7     \}\cb1 \
\cb7 \}\
\
Question 2:\
\pard\pardeftab720\partightenfactor0

\f0\b\fs24 \AppleTypeServices\AppleTypeServicesF65539 \cf11 \cb12 \strokec11 Count frequency of each element in the array
\f1\b0\fs32 \AppleTypeServices \cb1 \
\pard\pardeftab720\sa360\partightenfactor0

\f0\b\fs24 \cf13 \cb12 \strokec13 Problem statement:\'a0
\f1\b0 Given an array, we have found the number of occurrences of each element in the array.\cb1 \

\f0\b \cb12 Examples:
\f1\b0 \cb1 \
\pard\pardeftab720\partightenfactor0

\f4\b \cf13 \cb12 Example 1:
\f1\b0  
\f4\b Input:
\f1\b0  arr[] = \{10,5,10,15,10,5\}; 
\f4\b Output:
\f1\b0  10 3 5 2 15 1 
\f4\b Explanation:
\f1\b0  10 occurs 3 times in the array 5 occurs 2 times in the array 15 occurs 1 time in the array 
\f4\b Example2:
\f1\b0  
\f4\b Input:
\f1\b0  arr[] = \{2,2,3,4,4,2\}; 
\f4\b Output:
\f1\b0  2 3 3 1 4 2 
\f4\b Explanation:
\f1\b0  2 occurs 3 times in the array 3 occurs 1 time in the array 4 occurs 2 time in the array\cb1 \
\pard\pardeftab720\partightenfactor0

\f3\fs30 \cf0 \cb7 \strokec8 \

\fs24 My approach-
\fs30 \

\fs24 int[] arr = \{1, 2, 1, 3, 6, 2, 2\};\
        for (int i = 0; i < arr.length; i++) \{\
            int count = 0;\
            for (int j = 0; j < arr.length; j++) \{\
                if (arr[i] == arr[j]) \{\
                    count++;\
                \}\
            \}\
            System.out.println(arr[i] + " -> " + count);\
        \}\
\
But this gives output multiple times so corrected approach.\
\
int[] arr = \{1, 2, 1, 3, 6, 2, 2\};\
        HashSet<Integer> visited = new HashSet<>();\
\
        for (int i = 0; i < arr.length; i++) \{\
            if (!visited.contains(arr[i])) \{\
                int count = 0;\
                for (int j = 0; j < arr.length; j++) \{\
                    if (arr[i] == arr[j]) \{\
                        count++;\
                    \}\
                \}\
                visited.add(arr[i]);\
                System.out.println(arr[i] + " -> " + count);\
            \}\
        \}\
Using a hasheset can resolve this problem by adding the element once visited into the Hashmat so that the function call is not executed again for that element.\
\
Similar approach to solve this using list \
public List<List<Integer>> countFrequencies(int[] nums) \{\
        List<List<Integer>> result = new ArrayList<>();\
\
        List<Integer> visited = new ArrayList<>();\
\
        for (int i = 0; i < nums.length; i++) \{\
            int current = nums[i];\
\
            // Skip if already visited\
            if (visited.contains(current)) \{\
                continue;\
            \}\
\
            int count = 0;\
            for (int j = 0; j < nums.length; j++) \{\
                if (nums[j] == current) \{\
                    count++;\
                \}\
            \}\
\
            // Add to visited to avoid duplicates\
            visited.add(current);\
\
            // Add [number, frequency] to result\
            List<Integer> pair = new ArrayList<>();\
            pair.add(current);\
            pair.add(count);\
            result.add(pair);\
        \}\
        return result;\
    \}\
Another approach is using a map to map element and its frequency if element is present in map then increase its frequency by one else insert that element in the map with its initial frequency as 1.\
\pard\pardeftab720\partightenfactor0

\f5 \cf14 \cb15 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 static\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 void\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Frequency\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  arr[], \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  n)\
\{\
    \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Map\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 > map \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 new\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 HashMap\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <>();\
 \
    \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 for\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (\cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  i \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ; i \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  n; i\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ++\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
    \{\
        \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 containsKey\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i]))\
        \{\
            map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 put\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i], map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 get\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i]) \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 +\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 1\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 );\
        \}\
        \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        \{\
            map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 put\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i], \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 1\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 );\
        \}\
    \}\
    
\f6\i \cf19 \strokec19 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 // Traverse through map and print frequencies
\f5\i0 \cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
    \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 for\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Map\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Entry\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ,\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 > entry \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 :\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 entrySet\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ())\
    \{\
        \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 System\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .out.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 println\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (entry.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 getKey\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 () \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 +\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf20 \strokec20 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 " "\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 +\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  entry.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 getValue\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ());\
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f3\fs30 \cf0 \cb7 \strokec8 \shad0 \
\

\fs24 Question 3:\
\pard\pardeftab720\partightenfactor0

\f7\b \AppleTypeServices\AppleTypeServicesF65539 \cf21 \cb22 \strokec21 Highest Occurring Element in an Array\cb1 \
\pard\pardeftab720\partightenfactor0

\f8\b0 \AppleTypeServices \cf13 \cb22 \strokec13 \

\f9 \cf0 \cb1 \strokec8 Given an array of n integers, find the most frequent element in it i.e., the element that occurs the maximum number of times. If there are multiple elements that appear a maximum number of times, find the smallest of them.\
\

\f10\i Please note that this section might seem a bit difficult without prior knowledge on what hashing is, we will soon try to add basics concepts for your ease! If you know the concepts already please go ahead to give a shot to the problem. Cheers!
\f9\i0 \
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \
\pard\pardeftab720\partightenfactor0

\f11\b \cf21 \cb22 \strokec21 Examples:\

\f12 \cf23 \cb24 \strokec23 Input:
\f8\b0 \'a0arr = [1, 2, 2, 3, 3, 3]\cb1 \

\f12\b \cb24 Output:
\f8\b0 \'a03\cb1 \

\f12\b \cb24 Explanation:\'a0
\f8\b0 The number 3 appears the most (3 times).\'a0It is the most frequent element.\cb1 \

\f12\b \cb24 Input:
\f8\b0 \'a0arr = [4, 4, 5, 5, 6]\cb1 \

\f12\b \cb24 Output:
\f8\b0 \'a04\cb1 \

\f12\b \cb24 Explanation:
\f8\b0 \'a0Both 4 and 5 appear twice, but 4 is smaller. So, 4 is the most frequent element.
\fs28 \cb1 \
\pard\pardeftab720\partightenfactor0

\f3\fs30 \cf0 \cb7 \strokec8 \

\fs24 Approach just add two variables for max frequency and that element \
public static void main(String[] args) \{\
\
        int[] arr = \{1, 2, 1, 3, 6, 2, 2\};\
        HashSet<Integer> visited = new HashSet<>();\
        int maxfreq = 0;\
        int element = 0;\
        \
\
        for (int i = 0; i < arr.length; i++) \{\
            if (!visited.contains(arr[i])) \{\
                int count = 0;\
                for (int j = 0; j < arr.length; j++) \{\
                    if (arr[i] == arr[j]) \{\
                        count++;\
                    \}\
                \}\
                visited.add(arr[i]);\
                if(count > maxfreq) \{\
                    maxfreq = count;\
                    element = arr[i];\
                \}\
                System.out.println(arr[i] + " -> " + count);\
            \}\
        \}\
        System.out.println("Maximum Frequency = " + maxfreq + " and element = " + element);\
    \}\
\
But this brute force approach is not optimised to make it so we can use map like in previous question.\
\pard\pardeftab720\partightenfactor0

\f5 \cf14 \cb15 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 static\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 void\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Frequency\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  arr[], \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  n) \{\
        \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Map\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 > map \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 new\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 HashMap\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <>();\
\
        \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 for\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (\cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  i \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ; i \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  n; i\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ++\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) \{\
            \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 containsKey\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i])) \{\
                map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 put\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i], map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 get\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i]) \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 +\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 1\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 );\
            \} \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
                map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 put\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (arr[i], \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 1\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 );\
            \}\
        \}\
\
        \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  maxFreq \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , minFreq \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  n;\
        \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  maxEle \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , minEle \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ;\
        
\f6\i \cf19 \strokec19 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 // Traverse through map and find the elements
\f5\i0 \cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 for\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Map\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Entry\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Integer\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 > entry \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 :\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  map.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 entrySet\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()) \{\
            \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  count \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  entry.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 getValue\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ();\
            \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 int\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  element \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  entry.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 getKey\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ();\
\
            \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (count \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 >\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  maxFreq) \{\
                maxEle \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  element;\
                maxFreq \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  count;\
            \}\
            \cf14 \strokec14 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  (count \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 <\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  minFreq) \{\
                minEle \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  element;\
                minFreq \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 =\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  count;\
            \}\
        \}\
\
        \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 System\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .out.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 println\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf20 \strokec20 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "The highest frequency element is: "\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 +\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  maxEle);\
        \cf17 \strokec17 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 System\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .out.\cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 println\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf20 \strokec20 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "The lowest frequency element is: "\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf18 \strokec18 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 +\cf16 \strokec16 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  minEle);\
    \}\
\pard\pardeftab720\partightenfactor0

\f3 \cf0 \cb7 \strokec8 \shad0 \
With this approach the time complexity comes to be O(n).\

\fs30 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb1 \
}